function phi4z(e, t, n, r, i, s, o, u, a) { var f, l, c, h, p, d, a = s; for (d = 1; 15 >= d; d++) if (f = Math.sin(a), c = Math.tan(a), u = c * Math.sqrt(1 - e * f * f), l = Math.sin(2 * a), h = t * a - n * l + r * Math.sin(4 * a) - i * Math.sin(6 * a), p = t - 2 * n * Math.cos(2 * a) + 4 * r * Math.cos(4 * a) - 6 * i * Math.cos(6 * a), f = 2 * h + u * (h * h + o) - 2 * s * (u * h + 1), c = e * l * (h * h + o - 2 * s * h) / (2 * u), u = 2 * (s - h) * (u * p - 2 / l) - 2 * p, f /= c + u, a += f, 1e-10 >= Math.abs(f)) return a; Proj4js.reportError("phi4z: No convergence"); return null } function e4fn(e) { var t; t = 1 + e; e = 1 - e; return Math.sqrt(Math.pow(t, t) * Math.pow(e, e)) } var Proj4js = { defaultDatum: "WGS84", transform: function (e, t, n) { if (!e.readyToUse) return this.reportError("Proj4js initialization for:" + e.srsCode + " not yet complete"), n; if (!t.readyToUse) return this.reportError("Proj4js initialization for:" + t.srsCode + " not yet complete"), n; if (e.datum && t.datum && ((e.datum.datum_type == Proj4js.common.PJD_3PARAM || e.datum.datum_type == Proj4js.common.PJD_7PARAM) && "WGS84" != t.datumCode || (t.datum.datum_type == Proj4js.common.PJD_3PARAM || t.datum.datum_type == Proj4js.common.PJD_7PARAM) && "WGS84" != e.datumCode)) { var r = Proj4js.WGS84; this.transform(e, r, n); e = r } "enu" != e.axis && this.adjust_axis(e, !1, n); "longlat" == e.projName ? (n.x *= Proj4js.common.D2R, n.y *= Proj4js.common.D2R) : (e.to_meter && (n.x *= e.to_meter, n.y *= e.to_meter), e.inverse(n)); e.from_greenwich && (n.x += e.from_greenwich); n = this.datum_transform(e.datum, t.datum, n); t.from_greenwich && (n.x -= t.from_greenwich); "longlat" == t.projName ? (n.x *= Proj4js.common.R2D, n.y *= Proj4js.common.R2D) : (t.forward(n), t.to_meter && (n.x /= t.to_meter, n.y /= t.to_meter)); "enu" != t.axis && this.adjust_axis(t, !0, n); return n }, datum_transform: function (e, t, n) { if (e.compare_datums(t) || e.datum_type == Proj4js.common.PJD_NODATUM || t.datum_type == Proj4js.common.PJD_NODATUM) return n; if (e.es != t.es || e.a != t.a || e.datum_type == Proj4js.common.PJD_3PARAM || e.datum_type == Proj4js.common.PJD_7PARAM || t.datum_type == Proj4js.common.PJD_3PARAM || t.datum_type == Proj4js.common.PJD_7PARAM) e.geodetic_to_geocentric(n), (e.datum_type == Proj4js.common.PJD_3PARAM || e.datum_type == Proj4js.common.PJD_7PARAM) && e.geocentric_to_wgs84(n), (t.datum_type == Proj4js.common.PJD_3PARAM || t.datum_type == Proj4js.common.PJD_7PARAM) && t.geocentric_from_wgs84(n), t.geocentric_to_geodetic(n); return n }, adjust_axis: function (e, t, n) { for (var r = n.x, i = n.y, s = n.z || 0, o, u, a = 0; 3 > a; a++) if (!t || !(2 == a && void 0 === n.z)) switch (0 == a ? (o = r, u = "x") : 1 == a ? (o = i, u = "y") : (o = s, u = "z"), e.axis[a]) { case "e": n[u] = o; break; case "w": n[u] = -o; break; case "n": n[u] = o; break; case "s": n[u] = -o; break; case "u": void 0 !== n[u] && (n.z = o); break; case "d": void 0 !== n[u] && (n.z = -o); break; default: return alert("ERROR: unknow axis (" + e.axis[a] + ") - check definition of " + e.projName), null } return n }, reportError: function () { }, extend: function (e, t) { e = e || {}; if (t) for (var n in t) { var r = t[n]; void 0 !== r && (e[n] = r) } return e }, Class: function () { for (var e = function () { this.initialize.apply(this, arguments) }, t = {}, n, r = 0; r < arguments.length; ++r) n = "function" == typeof arguments[r] ? arguments[r].prototype : arguments[r], Proj4js.extend(t, n); e.prototype = t; return e }, bind: function (e, t) { var n = Array.prototype.slice.apply(arguments, [2]); return function () { var r = n.concat(Array.prototype.slice.apply(arguments, [0])); return e.apply(t, r) } }, scriptName: "proj4js-compressed.js", defsLookupService: "http://spatialreference.org/ref", libPath: null, getScriptLocation: function () { if (this.libPath) return this.libPath; for (var e = this.scriptName, t = e.length, n = document.getElementsByTagName("script"), r = 0; r < n.length; r++) { var i = n[r].getAttribute("src"); if (i) { var s = i.lastIndexOf(e); if (-1 < s && s + t == i.length) { this.libPath = i.slice(0, -t); break } } } return this.libPath || "" }, loadScript: function (e, t, n, r) { var i = document.createElement("script"); i.defer = !1; i.type = "text/javascript"; i.id = e; i.src = e; i.onload = t; i.onerror = n; i.loadCheck = r; /MSIE/.test(navigator.userAgent) && (i.onreadystatechange = this.checkReadyState); document.getElementsByTagName("head")[0].appendChild(i) }, checkReadyState: function () { if ("loaded" == this.readyState) if (this.loadCheck()) this.onload(); else this.onerror() } }; Proj4js.Proj = Proj4js.Class({ readyToUse: !1, title: null, projName: null, units: null, datum: null, x0: 0, y0: 0, localCS: !1, queue: null, initialize: function (e, t) { this.srsCodeInput = e; this.queue = []; t && this.queue.push(t); if (0 <= e.indexOf("GEOGCS") || 0 <= e.indexOf("GEOCCS") || 0 <= e.indexOf("PROJCS") || 0 <= e.indexOf("LOCAL_CS")) this.parseWKT(e), this.deriveConstants(), this.loadProjCode(this.projName); else { if (0 == e.indexOf("urn:")) { var n = e.split(":"); if (("ogc" == n[1] || "x-ogc" == n[1]) && "def" == n[2] && "crs" == n[3]) e = n[4] + ":" + n[n.length - 1] } else 0 == e.indexOf("http://") && (n = e.split("#"), n[0].match(/epsg.org/) ? e = "EPSG:" + n[1] : n[0].match(/RIG.xml/) && (e = "IGNF:" + n[1])); this.srsCode = e.toUpperCase(); 0 == this.srsCode.indexOf("EPSG") ? (this.srsCode = this.srsCode, this.srsAuth = "epsg", this.srsProjNumber = this.srsCode.substring(5)) : 0 == this.srsCode.indexOf("IGNF") ? (this.srsCode = this.srsCode, this.srsAuth = "IGNF", this.srsProjNumber = this.srsCode.substring(5)) : 0 == this.srsCode.indexOf("CRS") ? (this.srsCode = this.srsCode, this.srsAuth = "CRS", this.srsProjNumber = this.srsCode.substring(4)) : (this.srsAuth = "", this.srsProjNumber = this.srsCode); this.loadProjDefinition() } }, loadProjDefinition: function () { if (Proj4js.defs[this.srsCode]) this.defsLoaded(); else { var e = Proj4js.getScriptLocation() + "defs/" + this.srsAuth.toUpperCase() + this.srsProjNumber + ".js"; Proj4js.loadScript(e, Proj4js.bind(this.defsLoaded, this), Proj4js.bind(this.loadFromService, this), Proj4js.bind(this.checkDefsLoaded, this)) } }, loadFromService: function () { Proj4js.loadScript(Proj4js.defsLookupService + "/" + this.srsAuth + "/" + this.srsProjNumber + "/proj4js/", Proj4js.bind(this.defsLoaded, this), Proj4js.bind(this.defsFailed, this), Proj4js.bind(this.checkDefsLoaded, this)) }, defsLoaded: function () { this.parseDefs(); this.loadProjCode(this.projName) }, checkDefsLoaded: function () { return Proj4js.defs[this.srsCode] ? !0 : !1 }, defsFailed: function () { Proj4js.reportError("failed to load projection definition for: " + this.srsCode); Proj4js.defs[this.srsCode] = Proj4js.defs.WGS84; this.defsLoaded() }, loadProjCode: function (e) { if (Proj4js.Proj[e]) this.initTransforms(); else { var t = Proj4js.getScriptLocation() + "projCode/" + e + ".js"; Proj4js.loadScript(t, Proj4js.bind(this.loadProjCodeSuccess, this, e), Proj4js.bind(this.loadProjCodeFailure, this, e), Proj4js.bind(this.checkCodeLoaded, this, e)) } }, loadProjCodeSuccess: function (e) { Proj4js.Proj[e].dependsOn ? this.loadProjCode(Proj4js.Proj[e].dependsOn) : this.initTransforms() }, loadProjCodeFailure: function (e) { Proj4js.reportError("failed to find projection file for: " + e) }, checkCodeLoaded: function (e) { return Proj4js.Proj[e] ? !0 : !1 }, initTransforms: function () { Proj4js.extend(this, Proj4js.Proj[this.projName]); this.init(); this.readyToUse = !0; if (this.queue) for (var e; e = this.queue.shift() ;) e.call(this, this) }, wktRE: /^(\w+)\[(.*)\]$/, parseWKT: function (e) { if (e = e.match(this.wktRE)) { var t = e[1], n = e[2].split(","), r; r = "TOWGS84" == t.toUpperCase() ? t : n.shift(); r = r.replace(/^\"/, ""); r = r.replace(/\"$/, ""); for (var e = [], i = 0, s = "", o = 0; o < n.length; ++o) { for (var u = n[o], a = 0; a < u.length; ++a) "[" == u.charAt(a) && ++i, "]" == u.charAt(a) && --i; s += u; 0 === i ? (e.push(s), s = "") : s += "," } switch (t) { case "LOCAL_CS": this.projName = "identity"; this.localCS = !0; this.srsCode = r; break; case "GEOGCS": this.projName = "longlat"; this.geocsCode = r; this.srsCode || (this.srsCode = r); break; case "PROJCS": this.srsCode = r; break; case "PROJECTION": this.projName = Proj4js.wktProjections[r]; break; case "DATUM": this.datumName = r; break; case "LOCAL_DATUM": this.datumCode = "none"; break; case "SPHEROID": this.ellps = r; this.a = parseFloat(e.shift()); this.rf = parseFloat(e.shift()); break; case "PRIMEM": this.from_greenwich = parseFloat(e.shift()); break; case "UNIT": this.units = r; this.unitsPerMeter = parseFloat(e.shift()); break; case "PARAMETER": t = r.toLowerCase(); n = parseFloat(e.shift()); switch (t) { case "false_easting": this.x0 = n; break; case "false_northing": this.y0 = n; break; case "scale_factor": this.k0 = n; break; case "central_meridian": this.long0 = n * Proj4js.common.D2R; break; case "latitude_of_origin": this.lat0 = n * Proj4js.common.D2R } break; case "TOWGS84": this.datum_params = e; break; case "AXIS": t = r.toLowerCase(); n = e.shift(); switch (n) { case "EAST": n = "e"; break; case "WEST": n = "w"; break; case "NORTH": n = "n"; break; case "SOUTH": n = "s"; break; case "UP": n = "u"; break; case "DOWN": n = "d"; break; default: n = " " } this.axis || (this.axis = "enu"); switch (t) { case "x": this.axis = n + this.axis.substr(1, 2); break; case "y": this.axis = this.axis.substr(0, 1) + n + this.axis.substr(2, 1); break; case "z": this.axis = this.axis.substr(0, 2) + n } } for (o = 0; o < e.length; ++o) this.parseWKT(e[o]) } }, parseDefs: function () { this.defData = Proj4js.defs[this.srsCode]; var e, t; if (this.defData) { for (var n = this.defData.split("+"), r = 0; r < n.length; r++) switch (t = n[r].split("="), e = t[0].toLowerCase(), t = t[1], e.replace(/\s/gi, "")) { case "title": this.title = t; break; case "proj": this.projName = t.replace(/\s/gi, ""); break; case "units": this.units = t.replace(/\s/gi, ""); break; case "datum": this.datumCode = t.replace(/\s/gi, ""); break; case "nadgrids": this.nagrids = t.replace(/\s/gi, ""); break; case "ellps": this.ellps = t.replace(/\s/gi, ""); break; case "a": this.a = parseFloat(t); break; case "b": this.b = parseFloat(t); break; case "rf": this.rf = parseFloat(t); break; case "lat_0": this.lat0 = t * Proj4js.common.D2R; break; case "lat_1": this.lat1 = t * Proj4js.common.D2R; break; case "lat_2": this.lat2 = t * Proj4js.common.D2R; break; case "lat_ts": this.lat_ts = t * Proj4js.common.D2R; break; case "lon_0": this.long0 = t * Proj4js.common.D2R; break; case "alpha": this.alpha = parseFloat(t) * Proj4js.common.D2R; break; case "lonc": this.longc = t * Proj4js.common.D2R; break; case "x_0": this.x0 = parseFloat(t); break; case "y_0": this.y0 = parseFloat(t); break; case "k_0": this.k0 = parseFloat(t); break; case "k": this.k0 = parseFloat(t); break; case "r_a": this.R_A = !0; break; case "zone": this.zone = parseInt(t, 10); break; case "south": this.utmSouth = !0; break; case "towgs84": this.datum_params = t.split(","); break; case "to_meter": this.to_meter = parseFloat(t); break; case "from_greenwich": this.from_greenwich = t * Proj4js.common.D2R; break; case "pm": t = t.replace(/\s/gi, ""); this.from_greenwich = Proj4js.PrimeMeridian[t] ? Proj4js.PrimeMeridian[t] : parseFloat(t); this.from_greenwich *= Proj4js.common.D2R; break; case "axis": t = t.replace(/\s/gi, ""), 3 == t.length && -1 != "ewnsud".indexOf(t.substr(0, 1)) && -1 != "ewnsud".indexOf(t.substr(1, 1)) && -1 != "ewnsud".indexOf(t.substr(2, 1)) && (this.axis = t) } this.deriveConstants() } }, deriveConstants: function () { "@null" == this.nagrids && (this.datumCode = "none"); if (this.datumCode && "none" != this.datumCode) { var e = Proj4js.Datum[this.datumCode]; e && (this.datum_params = e.towgs84 ? e.towgs84.split(",") : null, this.ellps = e.ellipse, this.datumName = e.datumName ? e.datumName : this.datumCode) } this.a || Proj4js.extend(this, Proj4js.Ellipsoid[this.ellps] ? Proj4js.Ellipsoid[this.ellps] : Proj4js.Ellipsoid.WGS84); this.rf && !this.b && (this.b = (1 - 1 / this.rf) * this.a); if (0 === this.rf || Math.abs(this.a - this.b) < Proj4js.common.EPSLN) this.sphere = !0, this.b = this.a; this.a2 = this.a * this.a; this.b2 = this.b * this.b; this.es = (this.a2 - this.b2) / this.a2; this.e = Math.sqrt(this.es); this.R_A && (this.a *= 1 - this.es * (Proj4js.common.SIXTH + this.es * (Proj4js.common.RA4 + this.es * Proj4js.common.RA6)), this.a2 = this.a * this.a, this.b2 = this.b * this.b, this.es = 0); this.ep2 = (this.a2 - this.b2) / this.b2; this.k0 || (this.k0 = 1); this.axis || (this.axis = "enu"); this.datum = new Proj4js.datum(this) } }); Proj4js.Proj.longlat = { init: function () { }, forward: function (e) { return e }, inverse: function (e) { return e } }; Proj4js.Proj.identity = Proj4js.Proj.longlat; Proj4js.defs = { WGS84: "+title=long/lat:WGS84 +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees", "EPSG:4326": "+title=long/lat:WGS84 +proj=longlat +a=6378137.0 +b=6356752.31424518 +ellps=WGS84 +datum=WGS84 +units=degrees", "EPSG:4269": "+title=long/lat:NAD83 +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees", "EPSG:3875": "+title= Google Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs" }; Proj4js.defs["EPSG:3785"] = Proj4js.defs["EPSG:3875"]; Proj4js.defs.GOOGLE = Proj4js.defs["EPSG:3875"]; Proj4js.defs["EPSG:900913"] = Proj4js.defs["EPSG:3875"]; Proj4js.defs["EPSG:102113"] = Proj4js.defs["EPSG:3875"]; Proj4js.common = { PI: 3.141592653589793, HALF_PI: 1.5707963267948966, TWO_PI: 6.283185307179586, FORTPI: .7853981633974483, R2D: 57.29577951308232, D2R: .017453292519943295, SEC_TO_RAD: 484813681109536e-20, EPSLN: 1e-10, MAX_ITER: 20, COS_67P5: .3826834323650898, AD_C: 1.0026, PJD_UNKNOWN: 0, PJD_3PARAM: 1, PJD_7PARAM: 2, PJD_GRIDSHIFT: 3, PJD_WGS84: 4, PJD_NODATUM: 5, SRS_WGS84_SEMIMAJOR: 6378137, SIXTH: .16666666666666666, RA4: .04722222222222222, RA6: .022156084656084655, RV4: .06944444444444445, RV6: .04243827160493827, msfnz: function (e, t, n) { e *= t; return n / Math.sqrt(1 - e * e) }, tsfnz: function (e, t, n) { n *= e; n = Math.pow((1 - n) / (1 + n), .5 * e); return Math.tan(.5 * (this.HALF_PI - t)) / n }, phi2z: function (e, t) { for (var n = .5 * e, r, i = this.HALF_PI - 2 * Math.atan(t), s = 0; 15 >= s; s++) if (r = e * Math.sin(i), r = this.HALF_PI - 2 * Math.atan(t * Math.pow((1 - r) / (1 + r), n)) - i, i += r, 1e-10 >= Math.abs(r)) return i; alert("phi2z has NoConvergence"); return -9999 }, qsfnz: function (e, t) { var n; return 1e-7 < e ? (n = e * t, (1 - e * e) * (t / (1 - n * n) - .5 / e * Math.log((1 - n) / (1 + n)))) : 2 * t }, asinz: function (e) { 1 < Math.abs(e) && (e = 1 < e ? 1 : -1); return Math.asin(e) }, e0fn: function (e) { return 1 - .25 * e * (1 + e / 16 * (3 + 1.25 * e)) }, e1fn: function (e) { return .375 * e * (1 + .25 * e * (1 + .46875 * e)) }, e2fn: function (e) { return .05859375 * e * e * (1 + .75 * e) }, e3fn: function (e) { return e * e * e * (35 / 3072) }, mlfn: function (e, t, n, r, i) { return e * i - t * Math.sin(2 * i) + n * Math.sin(4 * i) - r * Math.sin(6 * i) }, srat: function (e, t) { return Math.pow((1 - e) / (1 + e), t) }, sign: function (e) { return 0 > e ? -1 : 1 }, adjust_lon: function (e) { return e = Math.abs(e) < this.PI ? e : e - this.sign(e) * this.TWO_PI }, adjust_lat: function (e) { return e = Math.abs(e) < this.HALF_PI ? e : e - this.sign(e) * this.PI }, latiso: function (e, t, n) { if (Math.abs(t) > this.HALF_PI) return +Number.NaN; if (t == this.HALF_PI) return Number.POSITIVE_INFINITY; if (t == -1 * this.HALF_PI) return -1 * Number.POSITIVE_INFINITY; n *= e; return Math.log(Math.tan((this.HALF_PI + t) / 2)) + e * Math.log((1 - n) / (1 + n)) / 2 }, fL: function (e, t) { return 2 * Math.atan(e * Math.exp(t)) - this.HALF_PI }, invlatiso: function (e, t) { var n = this.fL(1, t), r = 0, i = 0; do r = n, i = e * Math.sin(r), n = this.fL(Math.exp(e * Math.log((1 + i) / (1 - i)) / 2), t); while (1e-12 < Math.abs(n - r)); return n }, sinh: function (e) { e = Math.exp(e); return (e - 1 / e) / 2 }, cosh: function (e) { e = Math.exp(e); return (e + 1 / e) / 2 }, tanh: function (e) { e = Math.exp(e); return (e - 1 / e) / (e + 1 / e) }, asinh: function (e) { return (0 <= e ? 1 : -1) * Math.log(Math.abs(e) + Math.sqrt(e * e + 1)) }, acosh: function (e) { return 2 * Math.log(Math.sqrt((e + 1) / 2) + Math.sqrt((e - 1) / 2)) }, atanh: function (e) { return Math.log((e - 1) / (e + 1)) / 2 }, gN: function (e, t, n) { t *= n; return e / Math.sqrt(1 - t * t) }, pj_enfn: function (e) { var t = []; t[0] = this.C00 - e * (this.C02 + e * (this.C04 + e * (this.C06 + e * this.C08))); t[1] = e * (this.C22 - e * (this.C04 + e * (this.C06 + e * this.C08))); var n = e * e; t[2] = n * (this.C44 - e * (this.C46 + e * this.C48)); n *= e; t[3] = n * (this.C66 - e * this.C68); t[4] = n * e * this.C88; return t }, pj_mlfn: function (e, t, n, r) { n *= t; t *= t; return r[0] * e - n * (r[1] + t * (r[2] + t * (r[3] + t * r[4]))) }, pj_inv_mlfn: function (e, t, n) { for (var r = 1 / (1 - t), i = e, s = Proj4js.common.MAX_ITER; s; --s) { var o = Math.sin(i), u = 1 - t * o * o, u = (this.pj_mlfn(i, o, Math.cos(i), n) - e) * u * Math.sqrt(u) * r, i = i - u; if (Math.abs(u) < Proj4js.common.EPSLN) return i } Proj4js.reportError("cass:pj_inv_mlfn: Convergence error"); return i }, C00: 1, C02: .25, C04: .046875, C06: .01953125, C08: .01068115234375, C22: .75, C44: .46875, C46: .013020833333333334, C48: .007120768229166667, C66: .3645833333333333, C68: .005696614583333333, C88: .3076171875 }; Proj4js.datum = Proj4js.Class({ initialize: function (e) { this.datum_type = Proj4js.common.PJD_WGS84; e.datumCode && "none" == e.datumCode && (this.datum_type = Proj4js.common.PJD_NODATUM); if (e && e.datum_params) { for (var t = 0; t < e.datum_params.length; t++) e.datum_params[t] = parseFloat(e.datum_params[t]); if (0 != e.datum_params[0] || 0 != e.datum_params[1] || 0 != e.datum_params[2]) this.datum_type = Proj4js.common.PJD_3PARAM; if (3 < e.datum_params.length && (0 != e.datum_params[3] || 0 != e.datum_params[4] || 0 != e.datum_params[5] || 0 != e.datum_params[6])) this.datum_type = Proj4js.common.PJD_7PARAM, e.datum_params[3] *= Proj4js.common.SEC_TO_RAD, e.datum_params[4] *= Proj4js.common.SEC_TO_RAD, e.datum_params[5] *= Proj4js.common.SEC_TO_RAD, e.datum_params[6] = e.datum_params[6] / 1e6 + 1 } e && (this.a = e.a, this.b = e.b, this.es = e.es, this.ep2 = e.ep2, this.datum_params = e.datum_params) }, compare_datums: function (e) { return this.datum_type != e.datum_type || this.a != e.a || 5e-11 < Math.abs(this.es - e.es) ? !1 : this.datum_type == Proj4js.common.PJD_3PARAM ? this.datum_params[0] == e.datum_params[0] && this.datum_params[1] == e.datum_params[1] && this.datum_params[2] == e.datum_params[2] : this.datum_type == Proj4js.common.PJD_7PARAM ? this.datum_params[0] == e.datum_params[0] && this.datum_params[1] == e.datum_params[1] && this.datum_params[2] == e.datum_params[2] && this.datum_params[3] == e.datum_params[3] && this.datum_params[4] == e.datum_params[4] && this.datum_params[5] == e.datum_params[5] && this.datum_params[6] == e.datum_params[6] : this.datum_type == Proj4js.common.PJD_GRIDSHIFT || e.datum_type == Proj4js.common.PJD_GRIDSHIFT ? (alert("ERROR: Grid shift transformations are not implemented."), !1) : !0 }, geodetic_to_geocentric: function (e) { var t = e.x, n = e.y, r = e.z ? e.z : 0, i, s, o; if (n < -Proj4js.common.HALF_PI && n > -1.001 * Proj4js.common.HALF_PI) n = -Proj4js.common.HALF_PI; else if (n > Proj4js.common.HALF_PI && n < 1.001 * Proj4js.common.HALF_PI) n = Proj4js.common.HALF_PI; else if (n < -Proj4js.common.HALF_PI || n > Proj4js.common.HALF_PI) return Proj4js.reportError("geocent:lat out of range:" + n), null; t > Proj4js.common.PI && (t -= 2 * Proj4js.common.PI); s = Math.sin(n); o = Math.cos(n); i = this.a / Math.sqrt(1 - this.es * s * s); n = (i + r) * o * Math.cos(t); t = (i + r) * o * Math.sin(t); r = (i * (1 - this.es) + r) * s; e.x = n; e.y = t; e.z = r; return 0 }, geocentric_to_geodetic: function (e) { var t, n, r, i, s, o, u, a, f, l, c = e.x; r = e.y; var h = e.z ? e.z : 0; t = Math.sqrt(c * c + r * r); n = Math.sqrt(c * c + r * r + h * h); if (1e-12 > t / this.a) { if (c = 0, 1e-12 > n / this.a) return } else c = Math.atan2(r, c); r = h / n; i = t / n; s = 1 / Math.sqrt(1 - this.es * (2 - this.es) * i * i); u = i * (1 - this.es) * s; a = r * s; l = 0; do l++, o = this.a / Math.sqrt(1 - this.es * a * a), n = t * u + h * a - o * (1 - this.es * a * a), o = this.es * o / (o + n), s = 1 / Math.sqrt(1 - o * (2 - o) * i * i), o = i * (1 - o) * s, s *= r, f = s * u - o * a, u = o, a = s; while (1e-24 < f * f && 30 > l); t = Math.atan(s / Math.abs(o)); e.x = c; e.y = t; e.z = n; return e }, geocentric_to_geodetic_noniter: function (e) { var t = e.x, n = e.y, r = e.z ? e.z : 0, i, s, o, u, a, t = parseFloat(t), n = parseFloat(n), r = parseFloat(r); a = !1; if (0 != t) i = Math.atan2(n, t); else if (0 < n) i = Proj4js.common.HALF_PI; else if (0 > n) i = -Proj4js.common.HALF_PI; else if (a = !0, i = 0, 0 < r) s = Proj4js.common.HALF_PI; else if (0 > r) s = -Proj4js.common.HALF_PI; else return; o = t * t + n * n; t = Math.sqrt(o); n = r * Proj4js.common.AD_C; o = Math.sqrt(n * n + o); n /= o; o = t / o; n = r + this.b * this.ep2 * n * n * n; u = t - this.a * this.es * o * o * o; o = Math.sqrt(n * n + u * u); n /= o; o = u / o; u = this.a / Math.sqrt(1 - this.es * n * n); r = o >= Proj4js.common.COS_67P5 ? t / o - u : o <= -Proj4js.common.COS_67P5 ? t / -o - u : r / n + u * (this.es - 1); !1 == a && (s = Math.atan(n / o)); e.x = i; e.y = s; e.z = r; return e }, geocentric_to_wgs84: function (e) { if (this.datum_type == Proj4js.common.PJD_3PARAM) e.x += this.datum_params[0], e.y += this.datum_params[1], e.z += this.datum_params[2]; else if (this.datum_type == Proj4js.common.PJD_7PARAM) { var t = this.datum_params[3], n = this.datum_params[4], r = this.datum_params[5], i = this.datum_params[6], s = i * (r * e.x + e.y - t * e.z) + this.datum_params[1], t = i * (-n * e.x + t * e.y + e.z) + this.datum_params[2]; e.x = i * (e.x - r * e.y + n * e.z) + this.datum_params[0]; e.y = s; e.z = t } }, geocentric_from_wgs84: function (e) { if (this.datum_type == Proj4js.common.PJD_3PARAM) e.x -= this.datum_params[0], e.y -= this.datum_params[1], e.z -= this.datum_params[2]; else if (this.datum_type == Proj4js.common.PJD_7PARAM) { var t = this.datum_params[3], n = this.datum_params[4], r = this.datum_params[5], i = this.datum_params[6], s = (e.x - this.datum_params[0]) / i, o = (e.y - this.datum_params[1]) / i, i = (e.z - this.datum_params[2]) / i; e.x = s + r * o - n * i; e.y = -r * s + o + t * i; e.z = n * s - t * o + i } } }); Proj4js.Point = Proj4js.Class({ initialize: function (e, t, n) { "object" == typeof e ? (this.x = e[0], this.y = e[1], this.z = e[2] || 0) : "string" == typeof e && "undefined" == typeof t ? (e = e.split(","), this.x = parseFloat(e[0]), this.y = parseFloat(e[1]), this.z = parseFloat(e[2]) || 0) : (this.x = e, this.y = t, this.z = n || 0) }, clone: function () { return new Proj4js.Point(this.x, this.y, this.z) }, toString: function () { return "x=" + this.x + ",y=" + this.y }, toShortString: function () { return this.x + ", " + this.y } }); Proj4js.PrimeMeridian = { greenwich: 0, lisbon: -9.131906111111, paris: 2.337229166667, bogota: -74.080916666667, madrid: -3.687938888889, rome: 12.452333333333, bern: 7.439583333333, jakarta: 106.807719444444, ferro: -17.666666666667, brussels: 4.367975, stockholm: 18.058277777778, athens: 23.7163375, oslo: 10.722916666667 }; Proj4js.Ellipsoid = { MERIT: { a: 6378137, rf: 298.257, ellipseName: "MERIT 1983" }, SGS85: { a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85" }, GRS80: { a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)" }, IAU76: { a: 6378140, rf: 298.257, ellipseName: "IAU 1976" }, airy: { a: 6377563.396, b: 6356256.91, ellipseName: "Airy 1830" }, "APL4.": { a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965" }, NWL9D: { a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965" }, mod_airy: { a: 6377340.189, b: 6356034.446, ellipseName: "Modified Airy" }, andrae: { a: 6377104.43, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)" }, aust_SA: { a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969" }, GRS67: { a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)" }, bessel: { a: 6377397.155, rf: 299.1528128, ellipseName: "Bessel 1841" }, bess_nam: { a: 6377483.865, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)" }, clrk66: { a: 6378206.4, b: 6356583.8, ellipseName: "Clarke 1866" }, clrk80: { a: 6378249.145, rf: 293.4663, ellipseName: "Clarke 1880 mod." }, CPM: { a: 6375738.7, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799" }, delmbr: { a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)" }, engelis: { a: 6378136.05, rf: 298.2566, ellipseName: "Engelis 1985" }, evrst30: { a: 6377276.345, rf: 300.8017, ellipseName: "Everest 1830" }, evrst48: { a: 6377304.063, rf: 300.8017, ellipseName: "Everest 1948" }, evrst56: { a: 6377301.243, rf: 300.8017, ellipseName: "Everest 1956" }, evrst69: { a: 6377295.664, rf: 300.8017, ellipseName: "Everest 1969" }, evrstSS: { a: 6377298.556, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)" }, fschr60: { a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960" }, fschr60m: { a: 6378155, rf: 298.3, ellipseName: "Fischer 1960" }, fschr68: { a: 6378150, rf: 298.3, ellipseName: "Fischer 1968" }, helmert: { a: 6378200, rf: 298.3, ellipseName: "Helmert 1906" }, hough: { a: 6378270, rf: 297, ellipseName: "Hough" }, intl: { a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)" }, kaula: { a: 6378163, rf: 298.24, ellipseName: "Kaula 1961" }, lerch: { a: 6378139, rf: 298.257, ellipseName: "Lerch 1979" }, mprts: { a: 6397300, rf: 191, ellipseName: "Maupertius 1738" }, new_intl: { a: 6378157.5, b: 6356772.2, ellipseName: "New International 1967" }, plessis: { a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)" }, krass: { a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942" }, SEasia: { a: 6378155, b: 6356773.3205, ellipseName: "Southeast Asia" }, walbeck: { a: 6376896, b: 6355834.8467, ellipseName: "Walbeck" }, WGS60: { a: 6378165, rf: 298.3, ellipseName: "WGS 60" }, WGS66: { a: 6378145, rf: 298.25, ellipseName: "WGS 66" }, WGS72: { a: 6378135, rf: 298.26, ellipseName: "WGS 72" }, WGS84: { a: 6378137, rf: 298.257223563, ellipseName: "WGS 84" }, sphere: { a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)" } }; Proj4js.Datum = { WGS84: { towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84" }, GGRS87: { towgs84: "-199.87,74.79,246.62", ellipse: "GRS80", datumName: "Greek_Geodetic_Reference_System_1987" }, NAD83: { towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983" }, NAD27: { nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat", ellipse: "clrk66", datumName: "North_American_Datum_1927" }, potsdam: { towgs84: "606.0,23.0,413.0", ellipse: "bessel", datumName: "Potsdam Rauenberg 1950 DHDN" }, carthage: { towgs84: "-263.0,6.0,431.0", ellipse: "clark80", datumName: "Carthage 1934 Tunisia" }, hermannskogel: { towgs84: "653.0,-212.0,449.0", ellipse: "bessel", datumName: "Hermannskogel" }, ire65: { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "mod_airy", datumName: "Ireland 1965" }, nzgd49: { towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993", ellipse: "intl", datumName: "New Zealand Geodetic Datum 1949" }, OSGB36: { towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894", ellipse: "airy", datumName: "Airy 1830" } }; Proj4js.WGS84 = new Proj4js.Proj("WGS84"); Proj4js.Datum.OSB36 = Proj4js.Datum.OSGB36; Proj4js.wktProjections = { "Lambert Tangential Conformal Conic Projection": "lcc", Mercator: "merc", "Popular Visualisation Pseudo Mercator": "merc", Mercator_1SP: "merc", Transverse_Mercator: "tmerc", "Transverse Mercator": "tmerc", "Lambert Azimuthal Equal Area": "laea", "Universal Transverse Mercator System": "utm" }; Proj4js.Proj.aea = { init: function () { Math.abs(this.lat1 + this.lat2) < Proj4js.common.EPSLN ? Proj4js.reportError("aeaInitEqualLatitudes") : (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.con = this.t1 = this.sin_po, this.ms1 = Proj4js.common.msfnz(this.e3, this.sin_po, this.cos_po), this.qs1 = Proj4js.common.qsfnz(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = Proj4js.common.msfnz(this.e3, this.sin_po, this.cos_po), this.qs2 = Proj4js.common.qsfnz(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Proj4js.common.qsfnz(this.e3, this.sin_po, this.cos_po), this.ns0 = Math.abs(this.lat1 - this.lat2) > Proj4js.common.EPSLN ? (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0) }, forward: function (e) { var t = e.x, n = e.y; this.sin_phi = Math.sin(n); this.cos_phi = Math.cos(n); var n = Proj4js.common.qsfnz(this.e3, this.sin_phi, this.cos_phi), n = this.a * Math.sqrt(this.c - this.ns0 * n) / this.ns0, r = this.ns0 * Proj4js.common.adjust_lon(t - this.long0), t = n * Math.sin(r) + this.x0, n = this.rh - n * Math.cos(r) + this.y0; e.x = t; e.y = n; return e }, inverse: function (e) { var t, n, r; e.x -= this.x0; e.y = this.rh - e.y + this.y0; 0 <= this.ns0 ? (t = Math.sqrt(e.x * e.x + e.y * e.y), n = 1) : (t = -Math.sqrt(e.x * e.x + e.y * e.y), n = -1); r = 0; 0 != t && (r = Math.atan2(n * e.x, n * e.y)); n = t * this.ns0 / this.a; t = (this.c - n * n) / this.ns0; 1e-10 <= this.e3 ? (n = 1 - .5 * (1 - this.es) * Math.log((1 - this.e3) / (1 + this.e3)) / this.e3, n = 1e-10 < Math.abs(Math.abs(n) - Math.abs(t)) ? this.phi1z(this.e3, t) : 0 <= t ? .5 * Proj4js.common.PI : -.5 * Proj4js.common.PI) : n = this.phi1z(this.e3, t); r = Proj4js.common.adjust_lon(r / this.ns0 + this.long0); e.x = r; e.y = n; return e }, phi1z: function (e, t) { var n, r, i, s, o = Proj4js.common.asinz(.5 * t); if (e < Proj4js.common.EPSLN) return o; for (var u = e * e, a = 1; 25 >= a; a++) if (n = Math.sin(o), r = Math.cos(o), i = e * n, s = 1 - i * i, n = .5 * s * s / r * (t / (1 - u) - n / s + .5 / e * Math.log((1 - i) / (1 + i))), o += n, 1e-7 >= Math.abs(n)) return o; Proj4js.reportError("aea:phi1z:Convergence error"); return null } }; Proj4js.Proj.sterea = { dependsOn: "gauss", init: function () { Proj4js.Proj.gauss.init.apply(this); this.rc ? (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative")) : Proj4js.reportError("sterea:init:E_ERROR_0") }, forward: function (e) { var t, n, r, i; e.x = Proj4js.common.adjust_lon(e.x - this.long0); Proj4js.Proj.gauss.forward.apply(this, [e]); t = Math.sin(e.y); n = Math.cos(e.y); r = Math.cos(e.x); i = this.k0 * this.R2 / (1 + this.sinc0 * t + this.cosc0 * n * r); e.x = i * n * Math.sin(e.x); e.y = i * (this.cosc0 * t - this.sinc0 * n * r); e.x = this.a * e.x + this.x0; e.y = this.a * e.y + this.y0; return e }, inverse: function (e) { var t, n, r, i; e.x = (e.x - this.x0) / this.a; e.y = (e.y - this.y0) / this.a; e.x /= this.k0; e.y /= this.k0; (i = Math.sqrt(e.x * e.x + e.y * e.y)) ? (r = 2 * Math.atan2(i, this.R2), t = Math.sin(r), n = Math.cos(r), r = Math.asin(n * this.sinc0 + e.y * t * this.cosc0 / i), t = Math.atan2(e.x * t, i * this.cosc0 * n - e.y * this.sinc0 * t)) : (r = this.phic0, t = 0); e.x = t; e.y = r; Proj4js.Proj.gauss.inverse.apply(this, [e]); e.x = Proj4js.common.adjust_lon(e.x + this.long0); return e } }; Proj4js.Proj.poly = { init: function () { 0 == this.lat0 && (this.lat0 = 90); this.temp = this.b / this.a; this.es = 1 - Math.pow(this.temp, 2); this.e = Math.sqrt(this.es); this.e0 = Proj4js.common.e0fn(this.es); this.e1 = Proj4js.common.e1fn(this.es); this.e2 = Proj4js.common.e2fn(this.es); this.e3 = Proj4js.common.e3fn(this.es); this.ml0 = Proj4js.common.mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0) }, forward: function (e) { var t, n, r, i, s; r = e.y; n = Proj4js.common.adjust_lon(e.x - this.long0); 1e-7 >= Math.abs(r) ? (s = this.x0 + this.a * n, t = this.y0 - this.a * this.ml0) : (t = Math.sin(r), n = Math.cos(r), r = Proj4js.common.mlfn(this.e0, this.e1, this.e2, this.e3, r), i = Proj4js.common.msfnz(this.e, t, n), n = t, s = this.x0 + this.a * i * Math.sin(n) / t, t = this.y0 + this.a * (r - this.ml0 + i * (1 - Math.cos(n)) / t)); e.x = s; e.y = t; return e }, inverse: function (e) { var t, n; e.x -= this.x0; e.y -= this.y0; t = this.ml0 + e.y / this.a; if (1e-7 >= Math.abs(t)) t = e.x / this.a + this.long0, n = 0; else { t = t * t + e.x / this.a * (e.x / this.a); t = phi4z(this.es, this.e0, this.e1, this.e2, this.e3, this.al, t, void 0, n); if (1 != t) return t; t = Proj4js.common.adjust_lon(Proj4js.common.asinz(NaN * e.x / this.a) / Math.sin(n) + this.long0) } e.x = t; e.y = n; return e } }; Proj4js.Proj.equi = { init: function () { this.x0 || (this.x0 = 0); this.y0 || (this.y0 = 0); this.lat0 || (this.lat0 = 0); this.long0 || (this.long0 = 0) }, forward: function (e) { var t = e.y, n = this.x0 + this.a * Proj4js.common.adjust_lon(e.x - this.long0) * Math.cos(this.lat0), t = this.y0 + this.a * t; this.t1 = n; this.t2 = Math.cos(this.lat0); e.x = n; e.y = t; return e }, inverse: function (e) { e.x -= this.x0; e.y -= this.y0; var t = e.y / this.a; Math.abs(t) > Proj4js.common.HALF_PI && Proj4js.reportError("equi:Inv:DataError"); var n = Proj4js.common.adjust_lon(this.long0 + e.x / (this.a * Math.cos(this.lat0))); e.x = n; e.y = t } }; Proj4js.Proj.merc = { init: function () { this.lat_ts && (this.k0 = this.sphere ? Math.cos(this.lat_ts) : Proj4js.common.msfnz(this.es, Math.sin(this.lat_ts), Math.cos(this.lat_ts))) }, forward: function (e) { var t = e.x, n = e.y; if (90 < n * Proj4js.common.R2D && -90 > n * Proj4js.common.R2D && 180 < t * Proj4js.common.R2D && -180 > t * Proj4js.common.R2D) return Proj4js.reportError("merc:forward: llInputOutOfRange: " + t + " : " + n), null; if (Math.abs(Math.abs(n) - Proj4js.common.HALF_PI) <= Proj4js.common.EPSLN) return Proj4js.reportError("merc:forward: ll2mAtPoles"), null; if (this.sphere) t = this.x0 + this.a * this.k0 * Proj4js.common.adjust_lon(t - this.long0), n = this.y0 + this.a * this.k0 * Math.log(Math.tan(Proj4js.common.FORTPI + .5 * n)); else var r = Math.sin(n), n = Proj4js.common.tsfnz(this.e, n, r), t = this.x0 + this.a * this.k0 * Proj4js.common.adjust_lon(t - this.long0), n = this.y0 - this.a * this.k0 * Math.log(n); e.x = t; e.y = n; return e }, inverse: function (e) { var t = e.x - this.x0, n = e.y - this.y0; if (this.sphere) n = Proj4js.common.HALF_PI - 2 * Math.atan(Math.exp(-n / this.a * this.k0)); else if (n = Math.exp(-n / (this.a * this.k0)), n = Proj4js.common.phi2z(this.e, n), -9999 == n) return Proj4js.reportError("merc:inverse: lat = -9999"), null; t = Proj4js.common.adjust_lon(this.long0 + t / (this.a * this.k0)); e.x = t; e.y = n; return e } }; Proj4js.Proj.utm = { dependsOn: "tmerc", init: function () { this.zone ? (this.lat0 = 0, this.long0 = (6 * Math.abs(this.zone) - 183) * Proj4js.common.D2R, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = .9996, Proj4js.Proj.tmerc.init.apply(this), this.forward = Proj4js.Proj.tmerc.forward, this.inverse = Proj4js.Proj.tmerc.inverse) : Proj4js.reportError("utm:init: zone must be specified for UTM") } }; Proj4js.Proj.eqdc = { init: function () { this.mode || (this.mode = 0); this.temp = this.b / this.a; this.es = 1 - Math.pow(this.temp, 2); this.e = Math.sqrt(this.es); this.e0 = Proj4js.common.e0fn(this.es); this.e1 = Proj4js.common.e1fn(this.es); this.e2 = Proj4js.common.e2fn(this.es); this.e3 = Proj4js.common.e3fn(this.es); this.sinphi = Math.sin(this.lat1); this.cosphi = Math.cos(this.lat1); this.ms1 = Proj4js.common.msfnz(this.e, this.sinphi, this.cosphi); this.ml1 = Proj4js.common.mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1); 0 != this.mode ? (Math.abs(this.lat1 + this.lat2) < Proj4js.common.EPSLN && Proj4js.reportError("eqdc:Init:EqualLatitudes"), this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = Proj4js.common.msfnz(this.e, this.sinphi, this.cosphi), this.ml2 = Proj4js.common.mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = Math.abs(this.lat1 - this.lat2) >= Proj4js.common.EPSLN ? (this.ms1 - this.ms2) / (this.ml2 - this.ml1) : this.sinphi) : this.ns = this.sinphi; this.g = this.ml1 + this.ms1 / this.ns; this.ml0 = Proj4js.common.mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); this.rh = this.a * (this.g - this.ml0) }, forward: function (e) { var t = e.x, n = this.a * (this.g - Proj4js.common.mlfn(this.e0, this.e1, this.e2, this.e3, e.y)), r = this.ns * Proj4js.common.adjust_lon(t - this.long0), t = this.x0 + n * Math.sin(r), n = this.y0 + this.rh - n * Math.cos(r); e.x = t; e.y = n; return e }, inverse: function (e) { e.x -= this.x0; e.y = this.rh - e.y + this.y0; var t, n; 0 <= this.ns ? (n = Math.sqrt(e.x * e.x + e.y * e.y), t = 1) : (n = -Math.sqrt(e.x * e.x + e.y * e.y), t = -1); var r = 0; 0 != n && (r = Math.atan2(t * e.x, t * e.y)); t = this.phi3z(this.g - n / this.a, this.e0, this.e1, this.e2, this.e3); r = Proj4js.common.adjust_lon(this.long0 + r / this.ns); e.x = r; e.y = t; return e }, phi3z: function (e, t, n, r, i) { var s, o; s = e; for (var u = 0; 15 > u; u++) if (o = (e + n * Math.sin(2 * s) - r * Math.sin(4 * s) + i * Math.sin(6 * s)) / t - s, s += o, 1e-10 >= Math.abs(o)) return s; Proj4js.reportError("PHI3Z-CONV:Latitude failed to converge after 15 iterations"); return null } }; Proj4js.Proj.tmerc = { init: function () { this.e0 = Proj4js.common.e0fn(this.es); this.e1 = Proj4js.common.e1fn(this.es); this.e2 = Proj4js.common.e2fn(this.es); this.e3 = Proj4js.common.e3fn(this.es); this.ml0 = this.a * Proj4js.common.mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0) }, forward: function (e) { var t = e.y, n = Proj4js.common.adjust_lon(e.x - this.long0), r, i; r = Math.sin(t); var s = Math.cos(t); if (this.sphere) { var o = s * Math.sin(n); if (1e-10 > Math.abs(Math.abs(o) - 1)) return Proj4js.reportError("tmerc:forward: Point projects into infinity"), 93; i = .5 * this.a * this.k0 * Math.log((1 + o) / (1 - o)); r = Math.acos(s * Math.cos(n) / Math.sqrt(1 - o * o)); 0 > t && (r = -r); t = this.a * this.k0 * (r - this.lat0) } else { i = s * n; var n = Math.pow(i, 2), s = this.ep2 * Math.pow(s, 2), o = Math.tan(t), u = Math.pow(o, 2); r = 1 - this.es * Math.pow(r, 2); r = this.a / Math.sqrt(r); t = this.a * Proj4js.common.mlfn(this.e0, this.e1, this.e2, this.e3, t); i = this.k0 * r * i * (1 + n / 6 * (1 - u + s + n / 20 * (5 - 18 * u + Math.pow(u, 2) + 72 * s - 58 * this.ep2))) + this.x0; t = this.k0 * (t - this.ml0 + r * o * n * (.5 + n / 24 * (5 - u + 9 * s + 4 * Math.pow(s, 2) + n / 30 * (61 - 58 * u + Math.pow(u, 2) + 600 * s - 330 * this.ep2)))) + this.y0 } e.x = i; e.y = t; return e }, inverse: function (e) { var t, n, r, i; if (this.sphere) { n = Math.exp(e.x / (this.a * this.k0)); var s = .5 * (n - 1 / n); r = this.lat0 + e.y / (this.a * this.k0); i = Math.cos(r); t = Math.sqrt((1 - i * i) / (1 + s * s)); n = Proj4js.common.asinz(t); 0 > r && (n = -n); t = 0 == s && 0 == i ? this.long0 : Proj4js.common.adjust_lon(Math.atan2(s, i) + this.long0) } else { var s = e.x - this.x0, o = e.y - this.y0; n = t = (this.ml0 + o / this.k0) / this.a; for (i = 0; ; i++) { r = (t + this.e1 * Math.sin(2 * n) - this.e2 * Math.sin(4 * n) + this.e3 * Math.sin(6 * n)) / this.e0 - n; n += r; if (Math.abs(r) <= Proj4js.common.EPSLN) break; if (6 <= i) return Proj4js.reportError("tmerc:inverse: Latitude failed to converge"), 95 } if (Math.abs(n) < Proj4js.common.HALF_PI) { t = Math.sin(n); r = Math.cos(n); var u = Math.tan(n); i = this.ep2 * Math.pow(r, 2); var o = Math.pow(i, 2), a = Math.pow(u, 2), f = Math.pow(a, 2); t = 1 - this.es * Math.pow(t, 2); var l = this.a / Math.sqrt(t); t = l * (1 - this.es) / t; var s = s / (l * this.k0), c = Math.pow(s, 2); n -= l * u * c / t * (.5 - c / 24 * (5 + 3 * a + 10 * i - 4 * o - 9 * this.ep2 - c / 30 * (61 + 90 * a + 298 * i + 45 * f - 252 * this.ep2 - 3 * o))); t = Proj4js.common.adjust_lon(this.long0 + s * (1 - c / 6 * (1 + 2 * a + i - c / 20 * (5 - 2 * i + 28 * a - 3 * o + 8 * this.ep2 + 24 * f))) / r) } else n = Proj4js.common.HALF_PI * Proj4js.common.sign(o), t = this.long0 } e.x = t; e.y = n; return e } }; Proj4js.defs.GOOGLE = "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"; Proj4js.defs["EPSG:900913"] = Proj4js.defs.GOOGLE; Proj4js.Proj.gstmerc = { init: function () { var e = this.b / this.a; this.e = Math.sqrt(1 - e * e); this.lc = this.long0; this.rs = Math.sqrt(1 + this.e * this.e * Math.pow(Math.cos(this.lat0), 4) / (1 - this.e * this.e)); var e = Math.sin(this.lat0), t = Math.asin(e / this.rs), n = Math.sin(t); this.cp = Proj4js.common.latiso(0, t, n) - this.rs * Proj4js.common.latiso(this.e, this.lat0, e); this.n2 = this.k0 * this.a * Math.sqrt(1 - this.e * this.e) / (1 - this.e * this.e * e * e); this.xs = this.x0; this.ys = this.y0 - this.n2 * t; this.title || (this.title = "Gauss Schreiber transverse mercator") }, forward: function (e) { var t = e.y, n = this.rs * (e.x - this.lc), t = this.cp + this.rs * Proj4js.common.latiso(this.e, t, Math.sin(t)), r = Math.asin(Math.sin(n) / Proj4js.common.cosh(t)), r = Proj4js.common.latiso(0, r, Math.sin(r)); e.x = this.xs + this.n2 * r; e.y = this.ys + this.n2 * Math.atan(Proj4js.common.sinh(t) / Math.cos(n)); return e }, inverse: function (e) { var t = e.x, n = e.y, r = Math.atan(Proj4js.common.sinh((t - this.xs) / this.n2) / Math.cos((n - this.ys) / this.n2)), t = Math.asin(Math.sin((n - this.ys) / this.n2) / Proj4js.common.cosh((t - this.xs) / this.n2)), t = Proj4js.common.latiso(0, t, Math.sin(t)); e.x = this.lc + r / this.rs; e.y = Proj4js.common.invlatiso(this.e, (t - this.cp) / this.rs); return e } }; Proj4js.Proj.ortho = { init: function () { this.sin_p14 = Math.sin(this.lat0); this.cos_p14 = Math.cos(this.lat0) }, forward: function (e) { var t, n, r, i, s; n = e.y; r = Proj4js.common.adjust_lon(e.x - this.long0); t = Math.sin(n); n = Math.cos(n); i = Math.cos(r); s = this.sin_p14 * t + this.cos_p14 * n * i; if (0 < s || Math.abs(s) <= Proj4js.common.EPSLN) var o = 1 * this.a * n * Math.sin(r), u = this.y0 + 1 * this.a * (this.cos_p14 * t - this.sin_p14 * n * i); else Proj4js.reportError("orthoFwdPointError"); e.x = o; e.y = u; return e }, inverse: function (e) { var t, n, r, i; e.x -= this.x0; e.y -= this.y0; t = Math.sqrt(e.x * e.x + e.y * e.y); t > this.a + 1e-7 && Proj4js.reportError("orthoInvDataError"); n = Proj4js.common.asinz(t / this.a); r = Math.sin(n); i = Math.cos(n); n = this.long0; Math.abs(t); r = Proj4js.common.asinz(i * this.sin_p14 + e.y * r * this.cos_p14 / t); t = Math.abs(this.lat0) - Proj4js.common.HALF_PI; Math.abs(t) <= Proj4js.common.EPSLN && (n = 0 <= this.lat0 ? Proj4js.common.adjust_lon(this.long0 + Math.atan2(e.x, -e.y)) : Proj4js.common.adjust_lon(this.long0 - Math.atan2(-e.x, e.y))); Math.sin(r); e.x = n; e.y = r; return e } }; Proj4js.Proj.krovak = { init: function () { this.a = 6377397.155; this.es = .006674372230614; this.e = Math.sqrt(this.es); this.lat0 || (this.lat0 = .863937979737193); this.long0 || (this.long0 = .4334234309119251); this.k0 || (this.k0 = .9999); this.s45 = .785398163397448; this.s90 = 2 * this.s45; this.fi0 = this.lat0; this.e2 = this.es; this.e = Math.sqrt(this.e2); this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)); this.uq = 1.04216856380474; this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa); this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2); this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g; this.k1 = this.k0; this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)); this.s0 = 1.37008346281555; this.n = Math.sin(this.s0); this.ro0 = this.k1 * this.n0 / Math.tan(this.s0); this.ad = this.s90 - this.uq }, forward: function (e) { var t, n, r; n = e.y; r = Proj4js.common.adjust_lon(e.x - this.long0); t = Math.pow((1 + this.e * Math.sin(n)) / (1 - this.e * Math.sin(n)), this.alfa * this.e / 2); t = 2 * (Math.atan(this.k * Math.pow(Math.tan(n / 2 + this.s45), this.alfa) / t) - this.s45); n = -r * this.alfa; r = Math.asin(Math.cos(this.ad) * Math.sin(t) + Math.sin(this.ad) * Math.cos(t) * Math.cos(n)); t = this.n * Math.asin(Math.cos(t) * Math.sin(n) / Math.cos(r)); r = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(r / 2 + this.s45), this.n); e.y = r * Math.cos(t) / 1; e.x = r * Math.sin(t) / 1; this.czech && (e.y *= -1, e.x *= -1); return e }, inverse: function (e) { var t, n, r; t = e.x; e.x = e.y; e.y = t; this.czech && (e.y *= -1, e.x *= -1); t = Math.sqrt(e.x * e.x + e.y * e.y); n = Math.atan2(e.y, e.x) / Math.sin(this.s0); r = 2 * (Math.atan(Math.pow(this.ro0 / t, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45); t = Math.asin(Math.cos(this.ad) * Math.sin(r) - Math.sin(this.ad) * Math.cos(r) * Math.cos(n)); n = Math.asin(Math.cos(r) * Math.sin(n) / Math.cos(t)); e.x = this.long0 - n / this.alfa; n = t; var i = r = 0; do e.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(t / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(n)) / (1 - this.e * Math.sin(n)), this.e / 2)) - this.s45), 1e-10 > Math.abs(n - e.y) && (r = 1), n = e.y, i += 1; while (0 == r && 15 > i); return 15 <= i ? (Proj4js.reportError("PHI3Z-CONV:Latitude failed to converge after 15 iterations"), null) : e } }; Proj4js.Proj.somerc = { init: function () { var e = this.lat0; this.lambda0 = this.long0; var t = Math.sin(e), n = this.a, r = 1 / this.rf, r = 2 * r - Math.pow(r, 2), i = this.e = Math.sqrt(r); this.R = this.k0 * n * Math.sqrt(1 - r) / (1 - r * Math.pow(t, 2)); this.alpha = Math.sqrt(1 + r / (1 - r) * Math.pow(Math.cos(e), 4)); this.b0 = Math.asin(t / this.alpha); this.K = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)) - this.alpha * Math.log(Math.tan(Math.PI / 4 + e / 2)) + this.alpha * i / 2 * Math.log((1 + i * t) / (1 - i * t)) }, forward: function (e) { var t = Math.log(Math.tan(Math.PI / 4 - e.y / 2)), n = this.e / 2 * Math.log((1 + this.e * Math.sin(e.y)) / (1 - this.e * Math.sin(e.y))), n = 2 * (Math.atan(Math.exp(-this.alpha * (t + n) + this.K)) - Math.PI / 4), r = this.alpha * (e.x - this.lambda0), t = Math.atan(Math.sin(r) / (Math.sin(this.b0) * Math.tan(n) + Math.cos(this.b0) * Math.cos(r))), n = Math.asin(Math.cos(this.b0) * Math.sin(n) - Math.sin(this.b0) * Math.cos(n) * Math.cos(r)); e.y = this.R / 2 * Math.log((1 + Math.sin(n)) / (1 - Math.sin(n))) + this.y0; e.x = this.R * t + this.x0; return e }, inverse: function (e) { for (var t = (e.x - this.x0) / this.R, n = 2 * (Math.atan(Math.exp((e.y - this.y0) / this.R)) - Math.PI / 4), r = Math.asin(Math.cos(this.b0) * Math.sin(n) + Math.sin(this.b0) * Math.cos(n) * Math.cos(t)), t = this.lambda0 + Math.atan(Math.sin(t) / (Math.cos(this.b0) * Math.cos(t) - Math.sin(this.b0) * Math.tan(n))) / this.alpha, n = 0, i = r, s = -1e3, o = 0; 1e-7 < Math.abs(i - s) ;) { if (20 < ++o) { Proj4js.reportError("omercFwdInfinity"); return } n = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + r / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(i)) / 2)); s = i; i = 2 * Math.atan(Math.exp(n)) - Math.PI / 2 } e.x = t; e.y = i; return e } }; Proj4js.Proj.stere = { ssfn_: function (e, t, n) { t *= n; return Math.tan(.5 * (Proj4js.common.HALF_PI + e)) * Math.pow((1 - t) / (1 + t), .5 * n) }, TOL: 1e-8, NITER: 8, CONV: 1e-10, S_POLE: 0, N_POLE: 1, OBLIQ: 2, EQUIT: 3, init: function () { this.phits = this.lat_ts ? this.lat_ts : Proj4js.common.HALF_PI; var e = Math.abs(this.lat0); this.mode = Math.abs(e) - Proj4js.common.HALF_PI < Proj4js.common.EPSLN ? 0 > this.lat0 ? this.S_POLE : this.N_POLE : e > Proj4js.common.EPSLN ? this.OBLIQ : this.EQUIT; this.phits = Math.abs(this.phits); if (this.es) { var t; switch (this.mode) { case this.N_POLE: case this.S_POLE: Math.abs(this.phits - Proj4js.common.HALF_PI) < Proj4js.common.EPSLN ? this.akm1 = 2 * this.k0 / Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)) : (e = Math.sin(this.phits), this.akm1 = Math.cos(this.phits) / Proj4js.common.tsfnz(this.e, this.phits, e), e *= this.e, this.akm1 /= Math.sqrt(1 - e * e)); break; case this.EQUIT: this.akm1 = 2 * this.k0; break; case this.OBLIQ: e = Math.sin(this.lat0), t = 2 * Math.atan(this.ssfn_(this.lat0, e, this.e)) - Proj4js.common.HALF_PI, e *= this.e, this.akm1 = 2 * this.k0 * Math.cos(this.lat0) / Math.sqrt(1 - e * e), this.sinX1 = Math.sin(t), this.cosX1 = Math.cos(t) } } else switch (this.mode) { case this.OBLIQ: this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0); case this.EQUIT: this.akm1 = 2 * this.k0; break; case this.S_POLE: case this.N_POLE: this.akm1 = Math.abs(this.phits - Proj4js.common.HALF_PI) >= Proj4js.common.EPSLN ? Math.cos(this.phits) / Math.tan(Proj4js.common.FORTPI - .5 * this.phits) : 2 * this.k0 } }, forward: function (e) { var t = e.x, t = Proj4js.common.adjust_lon(t - this.long0), n = e.y, r, i; if (this.sphere) { var s, o, u; s = Math.sin(n); o = Math.cos(n); u = Math.cos(t); t = Math.sin(t); switch (this.mode) { case this.EQUIT: i = 1 + o * u; i <= Proj4js.common.EPSLN && Proj4js.reportError("stere:forward:Equit"); i = this.akm1 / i; r = i * o * t; i *= s; break; case this.OBLIQ: i = 1 + this.sinph0 * s + this.cosph0 * o * u; i <= Proj4js.common.EPSLN && Proj4js.reportError("stere:forward:Obliq"); i = this.akm1 / i; r = i * o * t; i *= this.cosph0 * s - this.sinph0 * o * u; break; case this.N_POLE: u = -u, n = -n; case this.S_POLE: Math.abs(n - Proj4js.common.HALF_PI) < this.TOL && Proj4js.reportError("stere:forward:S_POLE"), i = this.akm1 * Math.tan(Proj4js.common.FORTPI + .5 * n), r = t * i, i *= u } } else { u = Math.cos(t); t = Math.sin(t); s = Math.sin(n); var a; if (this.mode == this.OBLIQ || this.mode == this.EQUIT) a = 2 * Math.atan(this.ssfn_(n, s, this.e)), o = Math.sin(a - Proj4js.common.HALF_PI), a = Math.cos(a); switch (this.mode) { case this.OBLIQ: n = this.akm1 / (this.cosX1 * (1 + this.sinX1 * o + this.cosX1 * a * u)); i = n * (this.cosX1 * o - this.sinX1 * a * u); r = n * a; break; case this.EQUIT: n = 2 * this.akm1 / (1 + a * u); i = n * o; r = n * a; break; case this.S_POLE: n = -n, u = -u, s = -s; case this.N_POLE: r = this.akm1 * Proj4js.common.tsfnz(this.e, n, s), i = -r * u } r *= t } e.x = r * this.a + this.x0; e.y = i * this.a + this.y0; return e }, inverse: function (e) { var t = (e.x - this.x0) / this.a, n = (e.y - this.y0) / this.a, r, i, s, o = r = 0, u, a = s = 0; if (this.sphere) { o = Math.sqrt(t * t + n * n); a = 2 * Math.atan(o / this.akm1); s = Math.sin(a); a = Math.cos(a); r = 0; switch (this.mode) { case this.EQUIT: i = Math.abs(o) <= Proj4js.common.EPSLN ? 0 : Math.asin(n * s / o); if (0 != a || 0 != t) r = Math.atan2(t * s, a * o); break; case this.OBLIQ: i = Math.abs(o) <= Proj4js.common.EPSLN ? this.phi0 : Math.asin(a * this.sinph0 + n * s * this.cosph0 / o); a -= this.sinph0 * Math.sin(i); if (0 != a || 0 != t) r = Math.atan2(t * s * this.cosph0, a * o); break; case this.N_POLE: n = -n; case this.S_POLE: i = Math.abs(o) <= Proj4js.common.EPSLN ? this.phi0 : Math.asin(this.mode == this.S_POLE ? -a : a), r = 0 == t && 0 == n ? 0 : Math.atan2(t, n) } e.x = Proj4js.common.adjust_lon(r + this.long0); e.y = i } else { u = Math.sqrt(t * t + n * n); switch (this.mode) { case this.OBLIQ: case this.EQUIT: r = 2 * Math.atan2(u * this.cosX1, this.akm1); s = Math.cos(r); i = Math.sin(r); o = 0 == u ? Math.asin(s * this.sinX1) : Math.asin(s * this.sinX1 + n * i * this.cosX1 / u); r = Math.tan(.5 * (Proj4js.common.HALF_PI + o)); t *= i; n = u * this.cosX1 * s - n * this.sinX1 * i; a = Proj4js.common.HALF_PI; s = .5 * this.e; break; case this.N_POLE: n = -n; case this.S_POLE: r = -u / this.akm1, o = Proj4js.common.HALF_PI - 2 * Math.atan(r), a = -Proj4js.common.HALF_PI, s = -.5 * this.e } for (u = this.NITER; u--; o = i) if (i = this.e * Math.sin(o), i = 2 * Math.atan(r * Math.pow((1 + i) / (1 - i), s)) - a, Math.abs(o - i) < this.CONV) return this.mode == this.S_POLE && (i = -i), r = 0 == t && 0 == n ? 0 : Math.atan2(t, n), e.x = Proj4js.common.adjust_lon(r + this.long0), e.y = i, e } } }; Proj4js.Proj.nzmg = { iterations: 1, init: function () { this.A = []; this.A[1] = .6399175073; this.A[2] = -.1358797613; this.A[3] = .063294409; this.A[4] = -.02526853; this.A[5] = .0117879; this.A[6] = -.0055161; this.A[7] = .0026906; this.A[8] = -.001333; this.A[9] = 67e-5; this.A[10] = -34e-5; this.B_re = []; this.B_im = []; this.B_re[1] = .7557853228; this.B_im[1] = 0; this.B_re[2] = .249204646; this.B_im[2] = .003371507; this.B_re[3] = -.001541739; this.B_im[3] = .04105856; this.B_re[4] = -.10162907; this.B_im[4] = .01727609; this.B_re[5] = -.26623489; this.B_im[5] = -.36249218; this.B_re[6] = -.6870983; this.B_im[6] = -1.1651967; this.C_re = []; this.C_im = []; this.C_re[1] = 1.3231270439; this.C_im[1] = 0; this.C_re[2] = -.577245789; this.C_im[2] = -.007809598; this.C_re[3] = .508307513; this.C_im[3] = -.112208952; this.C_re[4] = -.15094762; this.C_im[4] = .18200602; this.C_re[5] = 1.01418179; this.C_im[5] = 1.64497696; this.C_re[6] = 1.9660549; this.C_im[6] = 2.5127645; this.D = []; this.D[1] = 1.5627014243; this.D[2] = .5185406398; this.D[3] = -.03333098; this.D[4] = -.1052906; this.D[5] = -.0368594; this.D[6] = .007317; this.D[7] = .0122; this.D[8] = .00394; this.D[9] = -.0013 }, forward: function (e) { for (var t = 1e-5 * ((e.y - this.lat0) / Proj4js.common.SEC_TO_RAD), n = e.x - this.long0, r = 1, i = 0, s = 1; 10 >= s; s++) r *= t, i += this.A[s] * r; for (var t = i, r = 1, o = 0, u = 0, a = 0, s = 1; 6 >= s; s++) i = r * t - o * n, o = o * t + r * n, r = i, u = u + this.B_re[s] * r - this.B_im[s] * o, a = a + this.B_im[s] * r + this.B_re[s] * o; e.x = a * this.a + this.x0; e.y = u * this.a + this.y0; return e }, inverse: function (e) { for (var t = (e.y - this.y0) / this.a, n = (e.x - this.x0) / this.a, r = 1, i = 0, s, o = 0, u = 0, a = 1; 6 >= a; a++) s = r * t - i * n, i = i * t + r * n, r = s, o = o + this.C_re[a] * r - this.C_im[a] * i, u = u + this.C_im[a] * r + this.C_re[a] * i; for (r = 0; r < this.iterations; r++) { var f = o, l = u, c; s = t; i = n; for (a = 2; 6 >= a; a++) c = f * o - l * u, l = l * o + f * u, f = c, s += (a - 1) * (this.B_re[a] * f - this.B_im[a] * l), i += (a - 1) * (this.B_im[a] * f + this.B_re[a] * l); for (var f = 1, l = 0, h = this.B_re[1], p = this.B_im[1], a = 2; 6 >= a; a++) c = f * o - l * u, l = l * o + f * u, f = c, h += a * (this.B_re[a] * f - this.B_im[a] * l), p += a * (this.B_im[a] * f + this.B_re[a] * l); u = h * h + p * p; o = (s * h + i * p) / u; u = (i * h - s * p) / u } t = o; n = 1; o = 0; for (a = 1; 9 >= a; a++) n *= t, o += this.D[a] * n; a = this.lat0 + 1e5 * o * Proj4js.common.SEC_TO_RAD; e.x = this.long0 + u; e.y = a; return e } }; Proj4js.Proj.mill = { init: function () { }, forward: function (e) { var t = e.y, n = this.x0 + this.a * Proj4js.common.adjust_lon(e.x - this.long0), t = this.y0 + 1.25 * this.a * Math.log(Math.tan(Proj4js.common.PI / 4 + t / 2.5)); e.x = n; e.y = t; return e }, inverse: function (e) { e.x -= this.x0; e.y -= this.y0; var t = Proj4js.common.adjust_lon(this.long0 + e.x / this.a), n = 2.5 * (Math.atan(Math.exp(.8 * e.y / this.a)) - Proj4js.common.PI / 4); e.x = t; e.y = n; return e } }; Proj4js.Proj.gnom = { init: function () { this.sin_p14 = Math.sin(this.lat0); this.cos_p14 = Math.cos(this.lat0); this.infinity_dist = 1e3 * this.a; this.rc = 1 }, forward: function (e) { var t, n, r, i, s; n = e.y; r = Proj4js.common.adjust_lon(e.x - this.long0); t = Math.sin(n); n = Math.cos(n); i = Math.cos(r); s = this.sin_p14 * t + this.cos_p14 * n * i; 0 < s || Math.abs(s) <= Proj4js.common.EPSLN ? (r = this.x0 + 1 * this.a * n * Math.sin(r) / s, t = this.y0 + 1 * this.a * (this.cos_p14 * t - this.sin_p14 * n * i) / s) : (Proj4js.reportError("orthoFwdPointError"), r = this.x0 + this.infinity_dist * n * Math.sin(r), t = this.y0 + this.infinity_dist * (this.cos_p14 * t - this.sin_p14 * n * i)); e.x = r; e.y = t; return e }, inverse: function (e) { var t, n, r, i; e.x = (e.x - this.x0) / this.a; e.y = (e.y - this.y0) / this.a; e.x /= this.k0; e.y /= this.k0; (t = Math.sqrt(e.x * e.x + e.y * e.y)) ? (i = Math.atan2(t, this.rc), n = Math.sin(i), r = Math.cos(i), i = Proj4js.common.asinz(r * this.sin_p14 + e.y * n * this.cos_p14 / t), t = Math.atan2(e.x * n, t * this.cos_p14 * r - e.y * this.sin_p14 * n), t = Proj4js.common.adjust_lon(this.long0 + t)) : (i = this.phic0, t = 0); e.x = t; e.y = i; return e } }; Proj4js.Proj.sinu = { init: function () { this.sphere ? (this.n = 1, this.es = this.m = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = Proj4js.common.pj_enfn(this.es) }, forward: function (e) { var t, n; t = e.x; n = e.y; t = Proj4js.common.adjust_lon(t - this.long0); if (this.sphere) { if (this.m) for (var r = this.n * Math.sin(n), i = Proj4js.common.MAX_ITER; i; --i) { var s = (this.m * n + Math.sin(n) - r) / (this.m + Math.cos(n)); n -= s; if (Math.abs(s) < Proj4js.common.EPSLN) break } else n = 1 != this.n ? Math.asin(this.n * Math.sin(n)) : n; t = this.a * this.C_x * t * (this.m + Math.cos(n)); n *= this.a * this.C_y } else r = Math.sin(n), i = Math.cos(n), n = this.a * Proj4js.common.pj_mlfn(n, r, i, this.en), t = this.a * t * i / Math.sqrt(1 - this.es * r * r); e.x = t; e.y = n; return e }, inverse: function (e) { var t, n; e.x -= this.x0; e.y -= this.y0; if (this.sphere) e.y /= this.C_y, t = this.m ? Math.asin((this.m * e.y + Math.sin(e.y)) / this.n) : 1 != this.n ? Math.asin(Math.sin(e.y) / this.n) : e.y, n = e.x / (this.C_x * (this.m + Math.cos(e.y))); else { t = Proj4js.common.pj_inv_mlfn(e.y / this.a, this.es, this.en); var r = Math.abs(t); r < Proj4js.common.HALF_PI ? (r = Math.sin(t), n = this.long0 + e.x * Math.sqrt(1 - this.es * r * r) / (this.a * Math.cos(t)), n = Proj4js.common.adjust_lon(n)) : r - Proj4js.common.EPSLN < Proj4js.common.HALF_PI && (n = this.long0) } e.x = n; e.y = t; return e } }; Proj4js.Proj.vandg = { init: function () { this.R = 6370997 }, forward: function (e) { var t = e.y, n = Proj4js.common.adjust_lon(e.x - this.long0); Math.abs(t); var r = Proj4js.common.asinz(2 * Math.abs(t / Proj4js.common.PI)); (Math.abs(n) <= Proj4js.common.EPSLN || Math.abs(Math.abs(t) - Proj4js.common.HALF_PI) <= Proj4js.common.EPSLN) && Math.tan(.5 * r); var i = .5 * Math.abs(Proj4js.common.PI / n - n / Proj4js.common.PI), s = i * i, o = Math.sin(r), r = Math.cos(r), r = r / (o + r - 1), o = r * (2 / o - 1), o = o * o, s = Proj4js.common.PI * this.R * (i * (r - o) + Math.sqrt(s * (r - o) * (r - o) - (o + s) * (r * r - o))) / (o + s); 0 > n && (s = -s); n = this.x0 + s; s = Math.abs(s / (Proj4js.common.PI * this.R)); t = 0 <= t ? this.y0 + Proj4js.common.PI * this.R * Math.sqrt(1 - s * s - 2 * i * s) : this.y0 - Proj4js.common.PI * this.R * Math.sqrt(1 - s * s - 2 * i * s); e.x = n; e.y = t; return e }, inverse: function (e) { var t, n, r, i, s, o, u, a; e.x -= this.x0; e.y -= this.y0; a = Proj4js.common.PI * this.R; t = e.x / a; r = e.y / a; i = t * t + r * r; s = -Math.abs(r) * (1 + i); n = s - 2 * r * r + t * t; o = -2 * s + 1 + 2 * r * r + i * i; a = r * r / o + (2 * n * n * n / o / o / o - 9 * s * n / o / o) / 27; u = (s - n * n / 3 / o) / o; s = 2 * Math.sqrt(-u / 3); a = 3 * a / u / s; 1 < Math.abs(a) && (a = 0 <= a ? 1 : -1); a = Math.acos(a) / 3; n = 0 <= e.y ? (-s * Math.cos(a + Proj4js.common.PI / 3) - n / 3 / o) * Proj4js.common.PI : -(-s * Math.cos(a + Proj4js.common.PI / 3) - n / 3 / o) * Proj4js.common.PI; Math.abs(t); t = Proj4js.common.adjust_lon(this.long0 + Proj4js.common.PI * (i - 1 + Math.sqrt(1 + 2 * (t * t - r * r) + i * i)) / 2 / t); e.x = t; e.y = n; return e } }; Proj4js.Proj.cea = { init: function () { }, forward: function (e) { var t = e.y, n = this.x0 + this.a * Proj4js.common.adjust_lon(e.x - this.long0) * Math.cos(this.lat_ts), t = this.y0 + this.a * Math.sin(t) / Math.cos(this.lat_ts); e.x = n; e.y = t; return e }, inverse: function (e) { e.x -= this.x0; e.y -= this.y0; var t = Proj4js.common.adjust_lon(this.long0 + e.x / this.a / Math.cos(this.lat_ts)), n = Math.asin(e.y / this.a * Math.cos(this.lat_ts)); e.x = t; e.y = n; return e } }; Proj4js.Proj.eqc = { init: function () { this.x0 || (this.x0 = 0); this.y0 || (this.y0 = 0); this.lat0 || (this.lat0 = 0); this.long0 || (this.long0 = 0); this.lat_ts || (this.lat_ts = 0); this.title || (this.title = "Equidistant Cylindrical (Plate Carre)"); this.rc = Math.cos(this.lat_ts) }, forward: function (e) { var t = e.y, n = Proj4js.common.adjust_lon(e.x - this.long0), t = Proj4js.common.adjust_lat(t - this.lat0); e.x = this.x0 + this.a * n * this.rc; e.y = this.y0 + this.a * t; return e }, inverse: function (e) { var t = e.y; e.x = Proj4js.common.adjust_lon(this.long0 + (e.x - this.x0) / (this.a * this.rc)); e.y = Proj4js.common.adjust_lat(this.lat0 + (t - this.y0) / this.a); return e } }; Proj4js.Proj.cass = { init: function () { this.sphere || (this.en = Proj4js.common.pj_enfn(this.es), this.m0 = Proj4js.common.pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en)) }, C1: .16666666666666666, C2: .008333333333333333, C3: .041666666666666664, C4: .3333333333333333, C5: .06666666666666667, forward: function (e) { var t, n, r = e.x, i = e.y, r = Proj4js.common.adjust_lon(r - this.long0); this.sphere ? (t = Math.asin(Math.cos(i) * Math.sin(r)), n = Math.atan2(Math.tan(i), Math.cos(r)) - this.phi0) : (this.n = Math.sin(i), this.c = Math.cos(i), n = Proj4js.common.pj_mlfn(i, this.n, this.c, this.en), this.n = 1 / Math.sqrt(1 - this.es * this.n * this.n), this.tn = Math.tan(i), this.t = this.tn * this.tn, this.a1 = r * this.c, this.c *= this.es * this.c / (1 - this.es), this.a2 = this.a1 * this.a1, t = this.n * this.a1 * (1 - this.a2 * this.t * (this.C1 - (8 - this.t + 8 * this.c) * this.a2 * this.C2)), n -= this.m0 - this.n * this.tn * this.a2 * (.5 + (5 - this.t + 6 * this.c) * this.a2 * this.C3)); e.x = this.a * t + this.x0; e.y = this.a * n + this.y0; return e }, inverse: function (e) { e.x -= this.x0; e.y -= this.y0; var t = e.x / this.a, n = e.y / this.a; if (this.sphere) this.dd = n + this.lat0, n = Math.asin(Math.sin(this.dd) * Math.cos(t)), t = Math.atan2(Math.tan(t), Math.cos(this.dd)); else { var r = Proj4js.common.pj_inv_mlfn(this.m0 + n, this.es, this.en); this.tn = Math.tan(r); this.t = this.tn * this.tn; this.n = Math.sin(r); this.r = 1 / (1 - this.es * this.n * this.n); this.n = Math.sqrt(this.r); this.r *= (1 - this.es) * this.n; this.dd = t / this.n; this.d2 = this.dd * this.dd; n = r - this.n * this.tn / this.r * this.d2 * (.5 - (1 + 3 * this.t) * this.d2 * this.C3); t = this.dd * (1 + this.t * this.d2 * (-this.C4 + (1 + 3 * this.t) * this.d2 * this.C5)) / Math.cos(r) } e.x = Proj4js.common.adjust_lon(this.long0 + t); e.y = n; return e } }; Proj4js.Proj.gauss = { init: function () { var e = Math.sin(this.lat0), t = Math.cos(this.lat0), t = t * t; this.rc = Math.sqrt(1 - this.es) / (1 - this.es * e * e); this.C = Math.sqrt(1 + this.es * t * t / (1 - this.es)); this.phic0 = Math.asin(e / this.C); this.ratexp = .5 * this.C * this.e; this.K = Math.tan(.5 * this.phic0 + Proj4js.common.FORTPI) / (Math.pow(Math.tan(.5 * this.lat0 + Proj4js.common.FORTPI), this.C) * Proj4js.common.srat(this.e * e, this.ratexp)) }, forward: function (e) { var t = e.x, n = e.y; e.y = 2 * Math.atan(this.K * Math.pow(Math.tan(.5 * n + Proj4js.common.FORTPI), this.C) * Proj4js.common.srat(this.e * Math.sin(n), this.ratexp)) - Proj4js.common.HALF_PI; e.x = this.C * t; return e }, inverse: function (e) { for (var t = e.x / this.C, n = e.y, r = Math.pow(Math.tan(.5 * n + Proj4js.common.FORTPI) / this.K, 1 / this.C), i = Proj4js.common.MAX_ITER; 0 < i; --i) { n = 2 * Math.atan(r * Proj4js.common.srat(this.e * Math.sin(e.y), -.5 * this.e)) - Proj4js.common.HALF_PI; if (1e-14 > Math.abs(n - e.y)) break; e.y = n } if (!i) return Proj4js.reportError("gauss:inverse:convergence failed"), null; e.x = t; e.y = n; return e } }; Proj4js.Proj.omerc = { init: function () { this.mode || (this.mode = 0); this.lon1 || (this.lon1 = 0, this.mode = 1); this.lon2 || (this.lon2 = 0); this.lat2 || (this.lat2 = 0); var e = 1 - Math.pow(this.b / this.a, 2); Math.sqrt(e); this.sin_p20 = Math.sin(this.lat0); this.cos_p20 = Math.cos(this.lat0); this.con = 1 - this.es * this.sin_p20 * this.sin_p20; this.com = Math.sqrt(1 - e); this.bl = Math.sqrt(1 + this.es * Math.pow(this.cos_p20, 4) / (1 - e)); this.al = this.a * this.bl * this.k0 * this.com / this.con; Math.abs(this.lat0) < Proj4js.common.EPSLN ? this.el = this.d = this.ts = 1 : (this.ts = Proj4js.common.tsfnz(this.e, this.lat0, this.sin_p20), this.con = Math.sqrt(this.con), this.d = this.bl * this.com / (this.cos_p20 * this.con), this.f = 0 < this.d * this.d - 1 ? 0 <= this.lat0 ? this.d + Math.sqrt(this.d * this.d - 1) : this.d - Math.sqrt(this.d * this.d - 1) : this.d, this.el = this.f * Math.pow(this.ts, this.bl)); 0 != this.mode ? (this.g = .5 * (this.f - 1 / this.f), this.gama = Proj4js.common.asinz(Math.sin(this.alpha) / this.d), this.longc -= Proj4js.common.asinz(this.g * Math.tan(this.gama)) / this.bl, this.con = Math.abs(this.lat0), this.con > Proj4js.common.EPSLN && Math.abs(this.con - Proj4js.common.HALF_PI) > Proj4js.common.EPSLN ? (this.singam = Math.sin(this.gama), this.cosgam = Math.cos(this.gama), this.sinaz = Math.sin(this.alpha), this.cosaz = Math.cos(this.alpha), this.u = 0 <= this.lat0 ? this.al / this.bl * Math.atan(Math.sqrt(this.d * this.d - 1) / this.cosaz) : -(this.al / this.bl) * Math.atan(Math.sqrt(this.d * this.d - 1) / this.cosaz)) : Proj4js.reportError("omerc:Init:DataError")) : (this.sinphi = Math.sin(this.at1), this.ts1 = Proj4js.common.tsfnz(this.e, this.lat1, this.sinphi), this.sinphi = Math.sin(this.lat2), this.ts2 = Proj4js.common.tsfnz(this.e, this.lat2, this.sinphi), this.h = Math.pow(this.ts1, this.bl), this.l = Math.pow(this.ts2, this.bl), this.f = this.el / this.h, this.g = .5 * (this.f - 1 / this.f), this.j = (this.el * this.el - this.l * this.h) / (this.el * this.el + this.l * this.h), this.p = (this.l - this.h) / (this.l + this.h), this.dlon = this.lon1 - this.lon2, this.dlon < -Proj4js.common.PI && (this.lon2 -= 2 * Proj4js.common.PI), this.dlon > Proj4js.common.PI && (this.lon2 += 2 * Proj4js.common.PI), this.dlon = this.lon1 - this.lon2, this.longc = .5 * (this.lon1 + this.lon2) - Math.atan(this.j * Math.tan(.5 * this.bl * this.dlon) / this.p) / this.bl, this.dlon = Proj4js.common.adjust_lon(this.lon1 - this.longc), this.gama = Math.atan(Math.sin(this.bl * this.dlon) / this.g), this.alpha = Proj4js.common.asinz(this.d * Math.sin(this.gama)), Math.abs(this.lat1 - this.lat2) <= Proj4js.common.EPSLN ? Proj4js.reportError("omercInitDataError") : this.con = Math.abs(this.lat1), this.con <= Proj4js.common.EPSLN || Math.abs(this.con - Proj4js.common.HALF_PI) <= Proj4js.common.EPSLN ? Proj4js.reportError("omercInitDataError") : Math.abs(Math.abs(this.lat0) - Proj4js.common.HALF_PI) <= Proj4js.common.EPSLN && Proj4js.reportError("omercInitDataError"), this.singam = Math.sin(this.gam), this.cosgam = Math.cos(this.gam), this.sinaz = Math.sin(this.alpha), this.cosaz = Math.cos(this.alpha), this.u = 0 <= this.lat0 ? this.al / this.bl * Math.atan(Math.sqrt(this.d * this.d - 1) / this.cosaz) : -(this.al / this.bl) * Math.atan(Math.sqrt(this.d * this.d - 1) / this.cosaz)) }, forward: function (e) { var t, n, r, i, s; r = e.x; n = e.y; t = Math.sin(n); i = Proj4js.common.adjust_lon(r - this.longc); r = Math.sin(this.bl * i); Math.abs(Math.abs(n) - Proj4js.common.HALF_PI) > Proj4js.common.EPSLN ? (t = Proj4js.common.tsfnz(this.e, n, t), t = this.el / Math.pow(t, this.bl), s = .5 * (t - 1 / t), t = (s * this.singam - r * this.cosgam) / (.5 * (t + 1 / t)), n = Math.cos(this.bl * i), 1e-7 > Math.abs(n) ? r = this.al * this.bl * i : (r = this.al * Math.atan((s * this.cosgam + r * this.singam) / n) / this.bl, 0 > n && (r += Proj4js.common.PI * this.al / this.bl))) : (t = 0 <= n ? this.singam : -this.singam, r = this.al * n / this.bl); Math.abs(Math.abs(t) - 1) <= Proj4js.common.EPSLN && Proj4js.reportError("omercFwdInfinity"); i = .5 * this.al * Math.log((1 - t) / (1 + t)) / this.bl; r -= this.u; t = this.y0 + r * this.cosaz - i * this.sinaz; e.x = this.x0 + i * this.cosaz + r * this.sinaz; e.y = t; return e }, inverse: function (e) { var t, n, r, i; e.x -= this.x0; e.y -= this.y0; t = e.x * this.cosaz - e.y * this.sinaz; r = e.y * this.cosaz + e.x * this.sinaz; r += this.u; n = Math.exp(-this.bl * t / this.al); t = .5 * (n - 1 / n); n = .5 * (n + 1 / n); r = Math.sin(this.bl * r / this.al); i = (r * this.cosgam + t * this.singam) / n; Math.abs(Math.abs(i) - 1) <= Proj4js.common.EPSLN ? (t = this.longc, i = 0 <= i ? Proj4js.common.HALF_PI : -Proj4js.common.HALF_PI) : (n = 1 / this.bl, i = Math.pow(this.el / Math.sqrt((1 + i) / (1 - i)), n), i = Proj4js.common.phi2z(this.e, i), t = this.longc - Math.atan2(t * this.cosgam - r * this.singam, n) / this.bl, t = Proj4js.common.adjust_lon(t)); e.x = t; e.y = i; return e } }; Proj4js.Proj.lcc = { init: function () { this.lat2 || (this.lat2 = this.lat0); this.k0 || (this.k0 = 1); if (Math.abs(this.lat1 + this.lat2) < Proj4js.common.EPSLN) Proj4js.reportError("lcc:init: Equal Latitudes"); else { var e = this.b / this.a; this.e = Math.sqrt(1 - e * e); var e = Math.sin(this.lat1), t = Math.cos(this.lat1), t = Proj4js.common.msfnz(this.e, e, t), n = Proj4js.common.tsfnz(this.e, this.lat1, e), r = Math.sin(this.lat2), i = Math.cos(this.lat2), i = Proj4js.common.msfnz(this.e, r, i), r = Proj4js.common.tsfnz(this.e, this.lat2, r), s = Proj4js.common.tsfnz(this.e, this.lat0, Math.sin(this.lat0)); this.ns = Math.abs(this.lat1 - this.lat2) > Proj4js.common.EPSLN ? Math.log(t / i) / Math.log(n / r) : e; this.f0 = t / (this.ns * Math.pow(n, this.ns)); this.rh = this.a * this.f0 * Math.pow(s, this.ns); this.title || (this.title = "Lambert Conformal Conic") } }, forward: function (e) { var t = e.x, n = e.y; if (!(90 >= n && -90 <= n && 180 >= t && -180 <= t)) return Proj4js.reportError("lcc:forward: llInputOutOfRange: " + t + " : " + n), null; var r = Math.abs(Math.abs(n) - Proj4js.common.HALF_PI); if (r > Proj4js.common.EPSLN) n = Proj4js.common.tsfnz(this.e, n, Math.sin(n)), n = this.a * this.f0 * Math.pow(n, this.ns); else { r = n * this.ns; if (0 >= r) return Proj4js.reportError("lcc:forward: No Projection"), null; n = 0 } t = this.ns * Proj4js.common.adjust_lon(t - this.long0); e.x = this.k0 * n * Math.sin(t) + this.x0; e.y = this.k0 * (this.rh - n * Math.cos(t)) + this.y0; return e }, inverse: function (e) { var t, n, r, i = (e.x - this.x0) / this.k0, s = this.rh - (e.y - this.y0) / this.k0; 0 < this.ns ? (t = Math.sqrt(i * i + s * s), n = 1) : (t = -Math.sqrt(i * i + s * s), n = -1); r = 0; 0 != t && (r = Math.atan2(n * i, n * s)); if (0 != t || 0 < this.ns) { if (n = 1 / this.ns, t = Math.pow(t / (this.a * this.f0), n), t = Proj4js.common.phi2z(this.e, t), -9999 == t) return null } else t = -Proj4js.common.HALF_PI; r = Proj4js.common.adjust_lon(r / this.ns + this.long0); e.x = r; e.y = t; return e } }; Proj4js.Proj.laea = { S_POLE: 1, N_POLE: 2, EQUIT: 3, OBLIQ: 4, init: function () { var e = Math.abs(this.lat0); this.mode = Math.abs(e - Proj4js.common.HALF_PI) < Proj4js.common.EPSLN ? 0 > this.lat0 ? this.S_POLE : this.N_POLE : Math.abs(e) < Proj4js.common.EPSLN ? this.EQUIT : this.OBLIQ; if (0 < this.es) switch (this.qp = Proj4js.common.qsfnz(this.e, 1), this.mmf = .5 / (1 - this.es), this.apa = this.authset(this.es), this.mode) { case this.N_POLE: case this.S_POLE: this.dd = 1; break; case this.EQUIT: this.rq = Math.sqrt(.5 * this.qp); this.dd = 1 / this.rq; this.xmf = 1; this.ymf = .5 * this.qp; break; case this.OBLIQ: this.rq = Math.sqrt(.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = Proj4js.common.qsfnz(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd } else this.mode == this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)) }, forward: function (e) { var t, n, r = e.x, i = e.y, r = Proj4js.common.adjust_lon(r - this.long0); if (this.sphere) { var s, o, u; u = Math.sin(i); o = Math.cos(i); s = Math.cos(r); switch (this.mode) { case this.OBLIQ: case this.EQUIT: n = this.mode == this.EQUIT ? 1 + o * s : 1 + this.sinph0 * u + this.cosph0 * o * s; if (n <= Proj4js.common.EPSLN) return Proj4js.reportError("laea:fwd:y less than eps"), null; n = Math.sqrt(2 / n); t = n * o * Math.sin(r); n *= this.mode == this.EQUIT ? u : this.cosph0 * u - this.sinph0 * o * s; break; case this.N_POLE: s = -s; case this.S_POLE: if (Math.abs(i + this.phi0) < Proj4js.common.EPSLN) return Proj4js.reportError("laea:fwd:phi < eps"), null; n = Proj4js.common.FORTPI - .5 * i; n = 2 * (this.mode == this.S_POLE ? Math.cos(n) : Math.sin(n)); t = n * Math.sin(r); n *= s } } else { var a = o = 0, f = 0; s = Math.cos(r); r = Math.sin(r); u = Math.sin(i); u = Proj4js.common.qsfnz(this.e, u); if (this.mode == this.OBLIQ || this.mode == this.EQUIT) o = u / this.qp, a = Math.sqrt(1 - o * o); switch (this.mode) { case this.OBLIQ: f = 1 + this.sinb1 * o + this.cosb1 * a * s; break; case this.EQUIT: f = 1 + a * s; break; case this.N_POLE: f = Proj4js.common.HALF_PI + i; u = this.qp - u; break; case this.S_POLE: f = i - Proj4js.common.HALF_PI, u = this.qp + u } if (Math.abs(f) < Proj4js.common.EPSLN) return Proj4js.reportError("laea:fwd:b < eps"), null; switch (this.mode) { case this.OBLIQ: case this.EQUIT: f = Math.sqrt(2 / f); n = this.mode == this.OBLIQ ? this.ymf * f * (this.cosb1 * o - this.sinb1 * a * s) : (f = Math.sqrt(2 / (1 + a * s))) * o * this.ymf; t = this.xmf * f * a * r; break; case this.N_POLE: case this.S_POLE: 0 <= u ? (t = (f = Math.sqrt(u)) * r, n = s * (this.mode == this.S_POLE ? f : -f)) : t = n = 0 } } e.x = this.a * t + this.x0; e.y = this.a * n + this.y0; return e }, inverse: function (e) { e.x -= this.x0; e.y -= this.y0; var t = e.x / this.a, n = e.y / this.a, r; if (this.sphere) { var i = 0, s, o = 0; s = Math.sqrt(t * t + n * n); r = .5 * s; if (1 < r) return Proj4js.reportError("laea:Inv:DataError"), null; r = 2 * Math.asin(r); if (this.mode == this.OBLIQ || this.mode == this.EQUIT) o = Math.sin(r), i = Math.cos(r); switch (this.mode) { case this.EQUIT: r = Math.abs(s) <= Proj4js.common.EPSLN ? 0 : Math.asin(n * o / s); t *= o; n = i * s; break; case this.OBLIQ: r = Math.abs(s) <= Proj4js.common.EPSLN ? this.phi0 : Math.asin(i * this.sinph0 + n * o * this.cosph0 / s); t *= o * this.cosph0; n = (i - Math.sin(r) * this.sinph0) * s; break; case this.N_POLE: n = -n; r = Proj4js.common.HALF_PI - r; break; case this.S_POLE: r -= Proj4js.common.HALF_PI } t = 0 == n && (this.mode == this.EQUIT || this.mode == this.OBLIQ) ? 0 : Math.atan2(t, n) } else { r = 0; switch (this.mode) { case this.EQUIT: case this.OBLIQ: t /= this.dd; n *= this.dd; o = Math.sqrt(t * t + n * n); if (o < Proj4js.common.EPSLN) return e.x = 0, e.y = this.phi0, e; s = 2 * Math.asin(.5 * o / this.rq); i = Math.cos(s); t *= s = Math.sin(s); this.mode == this.OBLIQ ? (r = i * this.sinb1 + n * s * this.cosb1 / o, n = o * this.cosb1 * i - n * this.sinb1 * s) : (r = n * s / o, n = o * i); break; case this.N_POLE: n = -n; case this.S_POLE: r = t * t + n * n; if (!r) return e.x = 0, e.y = this.phi0, e; r = 1 - r / this.qp; this.mode == this.S_POLE && (r = -r) } t = Math.atan2(t, n); r = this.authlat(Math.asin(r), this.apa) } e.x = Proj4js.common.adjust_lon(this.long0 + t); e.y = r; return e }, P00: .3333333333333333, P01: .17222222222222222, P02: .10257936507936508, P10: .06388888888888888, P11: .0664021164021164, P20: .016415012942191543, authset: function (e) { var t, n = []; n[0] = e * this.P00; t = e * e; n[0] += t * this.P01; n[1] = t * this.P10; t *= e; n[0] += t * this.P02; n[1] += t * this.P11; n[2] = t * this.P20; return n }, authlat: function (e, t) { var n = e + e; return e + t[0] * Math.sin(n) + t[1] * Math.sin(n + n) + t[2] * Math.sin(n + n + n) } }; Proj4js.Proj.aeqd = { init: function () { this.sin_p12 = Math.sin(this.lat0); this.cos_p12 = Math.cos(this.lat0) }, forward: function (e) { var t = e.x, n, r = Math.sin(e.y), i = Math.cos(e.y), t = Proj4js.common.adjust_lon(t - this.long0), s = Math.cos(t), o = this.sin_p12 * r + this.cos_p12 * i * s; if (Math.abs(Math.abs(o) - 1) < Proj4js.common.EPSLN) { if (n = 1, 0 > o) { Proj4js.reportError("aeqd:Fwd:PointError"); return } } else n = Math.acos(o), n /= Math.sin(n); e.x = this.x0 + this.a * n * i * Math.sin(t); e.y = this.y0 + this.a * n * (this.cos_p12 * r - this.sin_p12 * i * s); return e }, inverse: function (e) { e.x -= this.x0; e.y -= this.y0; var t = Math.sqrt(e.x * e.x + e.y * e.y); if (t > 2 * Proj4js.common.HALF_PI * this.a) Proj4js.reportError("aeqdInvDataError"); else { var n = t / this.a, r = Math.sin(n), n = Math.cos(n), i = this.long0, s; if (Math.abs(t) <= Proj4js.common.EPSLN) s = this.lat0; else { s = Proj4js.common.asinz(n * this.sin_p12 + e.y * r * this.cos_p12 / t); var o = Math.abs(this.lat0) - Proj4js.common.HALF_PI; Math.abs(o) <= Proj4js.common.EPSLN ? i = 0 <= this.lat0 ? Proj4js.common.adjust_lon(this.long0 + Math.atan2(e.x, -e.y)) : Proj4js.common.adjust_lon(this.long0 - Math.atan2(-e.x, e.y)) : (o = n - this.sin_p12 * Math.sin(s), Math.abs(o) < Proj4js.common.EPSLN && Math.abs(e.x) < Proj4js.common.EPSLN || (Math.atan2(e.x * r * this.cos_p12, o * t), i = Proj4js.common.adjust_lon(this.long0 + Math.atan2(e.x * r * this.cos_p12, o * t)))) } e.x = i; e.y = s; return e } } }; Proj4js.Proj.moll = { init: function () { }, forward: function (e) { for (var t = e.y, n = Proj4js.common.adjust_lon(e.x - this.long0), r = t, i = Proj4js.common.PI * Math.sin(t), s = 0; ; s++) { var o = -(r + Math.sin(r) - i) / (1 + Math.cos(r)), r = r + o; if (Math.abs(o) < Proj4js.common.EPSLN) break; 50 <= s && Proj4js.reportError("moll:Fwd:IterationError") } r /= 2; Proj4js.common.PI / 2 - Math.abs(t) < Proj4js.common.EPSLN && (n = 0); t = .900316316158 * this.a * n * Math.cos(r) + this.x0; r = 1.4142135623731 * this.a * Math.sin(r) + this.y0; e.x = t; e.y = r; return e }, inverse: function (e) { var t; e.x -= this.x0; t = e.y / (1.4142135623731 * this.a); .999999999999 < Math.abs(t) && (t = .999999999999); t = Math.asin(t); var n = Proj4js.common.adjust_lon(this.long0 + e.x / (.900316316158 * this.a * Math.cos(t))); n < -Proj4js.common.PI && (n = -Proj4js.common.PI); n > Proj4js.common.PI && (n = Proj4js.common.PI); t = (2 * t + Math.sin(2 * t)) / Proj4js.common.PI; 1 < Math.abs(t) && (t = 1); t = Math.asin(t); e.x = n; e.y = t; return e } }